* Wrapper classes are immutable = classes that don't allow changes to the
state of their instances after initialization. The wrapper class variable
is assigned a new object.

* all wrapper classes extends the class java.lang.nuber classes Boolean and
Character directly extend the class Object.

* You can create objects of all the wrapper classes in the multiple ways:
	1. Assignment - By assigning a primitive to a wrapper class variable (autoboxing)

	Boolean b = true;
	Byte byte1 = 10;


	2. Constructor - By using wrapper class constructors
	They don't accept non-argument constructor because they are immutable and can't
	be changed later.

	Boolean bool2 = new Boolean("trUE");	// String argument is not case-sensitive
	Byte byte2 = new Byte("10");


	3. Static methods - By calling static method of wrapper classes, like, valueOf()

	Boolean bool4 = Boolean.valueOf(true);
	Double double4 = Double.valueOf(10.2);


* All wrapper classes define a constructor that accepts a String argument representing
the primitive value that needs to be wrapped.

* All wrapper classes (except Characters) define a constructor that accepts a String
argument representing the primitive value that needs to be wrapped.

NB! * None of the wrapper class defines a no-argument constructor.

* You can assign a primitive value directly to a reference variable of its wrapper class
type, called autoboxing. The reverse is unboxing, when an object of a primitive wrapper
class is converted to its corresponding primitive value.

* All wrapper classes define methods of the format primitive Value(), where the term
primitive refers to the exect primitive data type name.

* To get a primitive data type value corresponding to a string value, you can use the
static utility method parseDataType, where DataType refers to the type of the return
value.

* The valueOf() method returns an object of the corresponding wrapper class when it's
passed an argument of a primitive type or String.

* You can compare object of wrapper classes for equality by using the method equals
or the comparison operator, ==.

NB! * The method "equals" always compares the primitive value stored by a wrapper
instance and == compares object references. The operator == return true if the variables
being compared refer to the same instance.

* In the case of the Boolean class, the cached instance are accessible directly
because only two exist: the static constants Boolean.TRUE and Boolean.FALSE.

NB! * The Character class caches instances with values from 0 to 127. Classes Byte, Short,
Integer and Long cache instances for values -128 to 127.

NB! * No cached instances exist for the Float and Double wrapper classes.

NB! * Wrapper classes are immutable. Adding a primitive value to a wrapper class variable
doesn't modify the value of the object it refers to. The wrapper class variable is
assigned a new object.

* Unboxing a wrapper reference variable, which refers to null, will throw a NullPointerException












					Comparing objects of wrapper class

*The valueOf() method return an object of the corresponding wrapper
when it's passed an argument of a primitive type or String.

NB!* Wrapper classes Byte, Short, Integer, Long cache objects with
	values of the range -128 to 127. The Character class caches objects
	with values 0 to 127.
	These classes define inner static classes that store
	objects for the primitive values -128 to 127 of 0 to 127 in an array.
	If ypu request and obhect of any of these classes, from this range,
	the valueOf() method retunrs a reference to a predefined object;
	otherwise, it creates a new object and returns its reference;

	of any of these classes, from the range, the valueOf() method
	returns a reference toa  predefined object, otherwise it creates a
	new object and returns its reference:

		Long var1 = Long.valueOf(123);
		Long var2 = Long.valueOf("123");
		System.out.println(var1 == var2);	// compare cached values

		Long var3 = Long.valueOf(223);
		Long var4 = Long.valueOf(233);
		System.out.println(var3 == var4);	// compare object instances

* No cached instances exists for Double and Float

* You can't compare wrapper instances for equality using equals() or ==
If they aren't of the same class. The code won't compile for instances that
are compared using ==. When compared using equals(), the output will be false.

* AUTOBOXING Java converts primitive types to their wrapper equivalence
-=/+= can be used only with primitives (wrappers are immutable!)

* UNBOXING converts wrapper classes to their primitive types equivalence
result of arithmetic operation may be stored in List of generics using
which requires conversion to object instance

* unboxing wrapper reference variable, which refers to null will throw
a NullPointerException



