
* Overloaded methods must have different method parameters from one another.

* Overloaded methods may or may not define a different return type.

* Overloaded methods may or may not define different access modifiers.

NB! * Overloaded methods can't be defined by only changing their return type or
access modifiers.

NB!* Changing only the return type won't make method an overloaded method.

* Overloaded methods fail to compile when the used calling arguments are dubious.

NB!* Overloaded constructors are invoked by using the keyword this — an implicit
reference that’s accessible to all objects that refer to an object itself:
Also, when you invoke an overloaded constructor using the keyword this, it must
be the first statement in your constructor:

class Employee {                    	class Employee {
String name;                        	String name;
int age;                            	int age;
  Employee() {                    	      Employee() {
  	// no code allowed before this.
  	this(null, 0);//legal use: this       Employee(null, 0);	//won't compile
  	// other code ...					  // other code ...
  }                              		}

Employee(String newName, int newAge) {  Employee(String newName, int newAge) {
  name = newName;                     	  name = newName;
  age = newAge;                       	  age = newAge;
  }                                   	  }
}                                       }

* Overloaded constructors must be defined using different argument lists.

* Overloaded constructors can’t be defined by just a change in the access levels.

* Overloaded constructors may be defined using different access levels.

* A constructor can’t invoke a constructor by using its class’s name.

* If present, the call to another constructor must be the first statement in a
constructor.

* You can’t call multiple constructors from a constructor.

* A constructor can’t be invoked from a method (except by instantiating a class
using the new keyword).
